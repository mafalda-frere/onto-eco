<!doctype html>
<html>
<head>
<meta charset="utf-8"/>
<title>Ontology-Driven Ecosystem Simulation</title>
<script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
<style>
body {
  font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif;
  margin: 20px;
}

.row {
  display: flex;
  gap: 10px;
  flex-wrap: wrap;
  align-items: center;
  margin-bottom: 16px;
}

/* === MAIN LAYOUT === */
.main-layout {
  display: flex;
  gap: 24px;
  align-items: flex-start;
}

/* LEFT: graph */
.left-panel {
  flex: 0 0 60%;
}

.left-panel canvas {
  max-width: 100%;
  height: 360px !important;
}

/* RIGHT: lists */
.right-panel {
  flex: 0 0 40%;
  display: flex;
  flex-direction: column;
  gap: 16px;
}

.panel-block {
  border: 1px solid #ddd;
  padding: 10px;
  border-radius: 6px;
  background: #fafafa;
  max-height: 280px;
  overflow-y: auto;
}

.panel-block ul {
  margin: 6px 0 0 0;
  padding-left: 18px;
}

</style>
</head>
<body>

<h2>Ontology-Driven Ecosystem Simulation</h2>

<div class="row">
  <select id="species"></select>
  <button onclick="addIndividual()">Add individual</button>
  <button onclick="autoEats()">Infer predator-prey relations</button>
  <button onclick="startSim()">Start simulation</button>
  <button onclick="resetAll()">Reset</button>
</div>

<div class="main-layout">

  <!-- LEFT: Graph -->
  <div class="left-panel">
    <h3>Population Dynamics</h3>
    <canvas id="popChart"></canvas>
  </div>

  <!-- RIGHT: Individuals + Eats -->
  <div class="right-panel">
    <div class="panel-block">
      <h3>Individuals</h3>
      <ul id="nodes"></ul>
    </div>

    <div class="panel-block">
      <h3>Predator–prey relations</h3>
      <ul id="edges"></ul>
    </div>
  </div>

</div>

<script>
function short(u){ return u.split('#').pop(); }

async function loadSpecies(){
  const sp = await fetch('/api/species').then(r=>r.json());
  species.innerHTML = "";
  sp.forEach(u=>{
    const o = document.createElement('option');
    o.value = u;
    o.textContent = short(u);
    species.appendChild(o);
  });
}

async function resetAll(){
  if(timer){
    clearInterval(timer);
    timer = null;
  }

  await fetch('/api/reset', { method: 'POST' });

  resetChart();
  refresh();
}

async function resetAll(){
  if(!confirm("Reset the simulation and remove all individuals?")) return;

  if(timer){
    clearInterval(timer);
    timer = null;
  }

  await fetch('/api/reset', { method: 'POST' });

  resetChart();
  refresh();
}

async function refresh(){
  const s = await fetch('/api/state').then(r=>r.json());

  nodes.innerHTML="";
  s.nodes.forEach(n=>{
    const li=document.createElement('li');
    const e = (n.energy===null || n.energy===undefined) ? "" : (" (E="+n.energy+")");
    li.textContent = short(n.id) + " → " + (n.types||[]).join(", ") + e;
    nodes.appendChild(li);
  });

  edges.innerHTML="";
  if((s.edges||[]).length === 0){
    const li=document.createElement('li');
    li.textContent="(no predator–prey relations)";
    edges.appendChild(li);
  } else {
    s.edges.forEach(e=>{
      const li=document.createElement('li');
      li.textContent = short(e.source) + " eats " + short(e.target);
      edges.appendChild(li);
    });
  }
}

async function addIndividual(){
  await fetch('/api/add_individual', {
    method:'POST',
    headers:{'Content-Type':'application/json'},
    body: JSON.stringify({species: species.value})
  });
  refresh();
}

async function autoEats(){
  await fetch('/api/auto_eats', {method:'POST'});
  refresh();
}

// ===== Chart unique multi-espèces =====
const palette = [
  "#e6194b","#3cb44b","#ffe119","#4363d8","#f58231","#911eb4",
  "#46f0f0","#f032e6","#bcf60c","#fabebe","#008080","#e6beff",
  "#9a6324","#fffac8","#800000","#aaffc3","#808000","#ffd8b1",
  "#000075","#808080"
];

function colorFor(label){
  let h = 0;
  for(let i=0;i<label.length;i++) h = (h*31 + label.charCodeAt(i)) >>> 0;
  return palette[h % palette.length];
}

let popChart = null;
let timer = null;

function resetChart(){
  const ctx = document.getElementById('popChart').getContext('2d');
  if(popChart){ 
    try { popChart.destroy(); } catch(e){} 
  }

  popChart = new Chart(ctx, {
    type: 'line',
    data: { labels: [], datasets: [] },
    options: {
      animation: false,
      responsive: true,
      maintainAspectRatio: false,
      interaction: { mode: 'nearest', intersect: false },
      scales: {
        x: { title: { display: true, text: 't' } },
        y: {
          title: { display: true, text: 'population' },
          beginAtZero: true,
          ticks: { precision: 0 }
        }
      },
      plugins: {
        legend: {
          position: 'bottom',
          labels: { boxWidth: 12 }
        }
      }
    }
  });
}



function ensureDataset(label){
  const existing = popChart.data.datasets.find(d => d.label === label);
  if(existing) return existing;
  const c = colorFor(label);
  const ds = {
    label,
    data: [],
    borderColor: c,
    backgroundColor: c,
    borderWidth: 2,
    pointRadius: 0,
    tension: 0.1
  };
  popChart.data.datasets.push(ds);
  return ds;
}

async function startSim(){
  resetChart();
  await fetch('/api/start', {method:'POST'});
  if(timer) clearInterval(timer);
  timer = setInterval(stepSim, 250);
}

async function stepSim(){
  const r = await fetch('/api/step', {method:'POST'}).then(r=>r.json());
  if(!r.ok) return;

  const history = r.history || {};
  const t = r.t || 0;

  popChart.data.labels = Array.from({length: t+1}, (_,i)=>i);

  Object.entries(history).forEach(([sp, values])=>{
    const label = short(sp);
    const ds = ensureDataset(label);
    ds.data = values;
  });

  popChart.update();

  if(r.status){
    clearInterval(timer);
    timer = null;
    alert("Simulation finished: " + r.status);
  }

  refresh();
}

loadSpecies().then(() => { resetChart(); refresh(); });
</script>

</body>
</html>
